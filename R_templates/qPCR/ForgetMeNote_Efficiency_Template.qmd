---
title: "qPCR of U2OS CHIKV"
author: "Jared Bard"
date: "12/19/2025"
format: 
  html:
    embed-resources: true
---

RNA was purified from U2OS cells infected with CHIKV for 8H by Thu

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE) # options for how knitr displays html documents upon rendering

# first install packages if necessary
if (!requireNamespace("BiocManager")) install.packages("BiocManager")
if (!requireNamespace("tidyverse")) install.packages("tidyverse")
if (!requireNamespace("cowplot")) install.packages("cowplot")
if (!requireNamespace("ggrepel")) install.packages("ggrepel")
if (!requireNamespace("scales")) install.packages("scales")
if (!requireNamespace("ggokabeito")) install.packages("ggokabeito")
if (!requireNamespace("flextable")) install.packages("flextable")
if (!requireNamespace("readxl")) install.packages("readxl")
if (!requireNamespace("devtools")) install.packages("devtools")
if (!requireNamespace("cat.extras")) devtools::install_github("jabard89/cat.extras") #convenient utility functions like prettier log scales

# then load packages
library(tidyverse)
library(cowplot)
library(cat.extras)
library(flextable)


conflicted::conflicts_prefer(dplyr::filter) # make sure that other packages don't take over "filter"
okabe_ito_colors <- list(
  black = "#000000",
  orange = "#E69F00", 
  sky_blue = "#56B4E9",
  bluish_green = "#009E73",
  yellow = "#F0E442",
  blue = "#0072B2",
  vermillion = "#D55E00",
  reddish_purple = "#CC79A7"
)
`%!in%` = Negate(`%in%`)
theme_set(theme_half_open(font_size=10))
```

# reading in the data


```{r}
src.directory <- c(".")

samples_plate1 <- readxl::read_excel(file.path(src.directory,"251219_test2_samples.xlsx"), sheet = "Plate1") %>%
  filter(!is.na(RNA_sample)) %>%
  mutate(Plate = "Plate1")
samples <- bind_rows(samples_plate1)
# this is the real data
sample1_file <- "251219_Test2.xlsx"
plate1 <- readxl::read_excel(file.path(src.directory,sample1_file), sheet = "Results", skip = 19) %>%
  mutate(Well = `Well Position`,
         Ct = as.numeric(CT)) %>%
  select(Well,Ct,Reporter) %>%
  right_join(samples_plate1 %>% filter(!is.na(Well)), by = "Well")

# this is the raw data for QC purposes
cycle_data <- readxl::read_excel(file.path(src.directory,sample1_file), sheet = "Multicomponent Data", skip = 19) %>%
  mutate(Well = `Well Position`) %>%
  filter(Cycle <= 40) %>%
  select(Well,Cycle,ROX,SYBR) %>%
  left_join(samples_plate1 %>% filter(!is.na(Well)), by = "Well") %>%
  pivot_longer(cols = c(ROX,SYBR), names_to = "Channel", values_to = "Value")

melt_data <- readxl::read_excel(file.path(src.directory,sample1_file), sheet = "Melt Curve Raw Data", skip = 19) %>%
  mutate(Well = `Well Position`) %>%
  select(Well,Reading,Temperature,Fluorescence,Derivative) %>%
  left_join(samples_plate1 %>% filter(!is.na(Well)), by = "Well") %>%
  filter(!is.na(Probe))

melt_peaks <- readxl::read_excel(file.path(src.directory,sample1_file), sheet = "Melt Curve Result", skip = 19) %>%
  mutate(Well = `Well Position`,
         Peak_height = `Melt Peak Height`) %>%
  select(Well,Tm,Peak_height) %>%
  left_join(samples_plate1 %>% filter(!is.na(Well)), by = "Well") %>%
  filter(!is.na(Probe)) %>%
  group_by(Well) %>%
  mutate(N_peaks = n())

raw_data <- bind_rows(plate1) %>% 
  replace_na(list(Skip=FALSE,RT=TRUE)) %>%
  filter(!is.na(Probe)) # remove any wells that don't have a probe

data_mean <- raw_data %>%
  filter(!Skip) %>%
  group_by(Plate,RNA_sample,RNA_conc_ng_per_uL,Probe,RT) %>%
  summarise(Ct.SD = sd(Ct),
            Ct.SE = sd(Ct)/sqrt(n()),
            Ct.mean = mean(Ct)) %>%
  ungroup %>%
  left_join(samples %>% select(-c(Well,Techrep,RT,Skip),-starts_with("Probe_")) %>% unique, by = c("Plate","RNA_sample"))
```
# have a peak at the raw raw data

```{r}
df_cycles <- cycle_data %>%
  separate(Well, into = c("Row", "Column"), sep = "(?<=\\D)(?=\\d)", remove = F) %>%
  mutate(Column = factor(as.numeric(Column))) %>%
  filter(Row %in% LETTERS[which(LETTERS == "A"):which(LETTERS == "O")],
         Column %in% seq(1,24)) %>%
  group_by(Plate,Well,Cycle) %>%
  mutate(Value.norm = Value/Value[Channel == "ROX"]) %>%
  ungroup

ggplot(df_cycles %>% filter(Channel %in% c("SYBR")),
       aes(x = Cycle, y= Value.norm, color = Channel)) +
  cowplot::theme_minimal_grid(font_size = 12) +
  geom_line() + 
  scale_y_log2nice() + 
  coord_cartesian(ylim = c(2^-3,2^4)) +
  facet_grid(Row ~ Column)
```
```{r}
df_rox <- cycle_data %>%
  separate(Well, into = c("Row", "Column"), sep = "(?<=\\D)(?=\\d)", remove = F) %>%
  mutate(Column = factor(as.numeric(Column))) %>%
  filter(Row %in% LETTERS[which(LETTERS == "A"):which(LETTERS == "O")],
         Column %in% seq(1,24)) %>%
  filter(!is.na(Probe), Channel == "ROX") %>% # filter for just wells in the spreadsheet
  mutate(Rox.norm = Value/mean(Value)) %>%
  ungroup

ggplot(df_rox,
       aes(x = Cycle, y= Rox.norm, color = Channel)) +
  cowplot::theme_half_open(font_size = 12) +
  geom_hline(yintercept = 1, linetype = "dotted") +
  geom_line() + 
  scale_y_log2nice() +
  facet_grid(Row ~ Column)
```

I noticed that H10 looks weird here, so I should keep an eye on those results (may need to be skipped).

# look at the melt peaks
If there are any melt curves with multiple peaks, that probably means the qPCR results are not reliable because the product is not clean. A single product should yield a single melt curve.

```{r}
df_melt <- melt_data %>%
  filter(RNA_conc_ng_per_uL != 0) %>%
  separate(Well, into = c("Row", "Column"), sep = "(?<=\\D)(?=\\d)", remove = F) %>%
  mutate(Column = factor(as.numeric(Column))) %>%
  filter(Row %in% LETTERS[which(LETTERS == "A"):which(LETTERS == "O")],
         Column %in% seq(1,24)) %>%
  left_join(melt_peaks %>% select(Well,Tm,Peak_height,N_peaks), by = "Well")

ggplot(df_melt,
       aes(x = Temperature, y= Derivative)) +
  cowplot::theme_minimal_grid(font_size = 12) +
  geom_line(aes(color = RT, group = Well)) + 
  facet_wrap(facets = "Probe")

ggplot(df_melt %>% filter(N_peaks > 1),
       aes(x = Temperature, y= Derivative)) +
  cowplot::theme_minimal_grid(font_size = 12) +
  geom_line(aes(color = RT, group = Well)) + 
  facet_wrap(facets = "Well") +
  labs(subtitle = "Potential Problems")
```
# now check the RT
Look for any outliers (1 techrep different from the other 2), and add a "TRUE" to the skip column in the sample spreadsheet if necessary.
```{r}
df <- raw_data

p_rt <-  ggplot(df,
               aes(x = RNA_sample, y = Ct, shape = Techrep, alpha = Skip)) + 
  cowplot::theme_minimal_grid(font_size = 12) +
  scale_alpha_manual(values = c(1,0.4), guide = "none") +
  cowplot::panel_border() +
  geom_point(aes(color = RT)) +
  facet_grid(Probe ~ .) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p_rt
```

```{r}
raw_data %>% filter(RT == TRUE) %>% 
  group_by(RNA_sample,Probe) %>%
  mutate(Ct.SD = sd(Ct),
            Ct.mean = mean(Ct)) %>%
  select(Well,RNA_sample,Probe,Techrep,Ct,Ct.SD,Ct.mean) %>% 
  arrange(desc(Ct.SD)) %>%
  flextable %>% autofit
```


Here I skipped C11,C7, C2, C8, E3, F5


# Plotting and Calculating Efficiencies

```{r}
if (!requireNamespace("ggpmisc")) install.packages("ggpmisc")
library(ggpmisc)
library(broom)

# --- Step 1: Prepare and Filter the Data ---
df_raw_filtered <- raw_data %>%
  filter(
    RT == TRUE,
    Skip != TRUE,
    !is.na(Ct),
    RNA_conc_ng_per_uL > 0
  )

# --- Step 2: Calculate Efficiency for Each Probe ---
# Fit models and calculate efficiency per probe
efficiency_data <- df_raw_filtered %>%
  filter(RNA_conc_ng_per_uL < 20) %>% # seems to level off
  group_by(Probe) %>%
  do({
    model <- lm(Ct ~ log10(RNA_conc_ng_per_uL), data = .)
    slope <- tidy(model) %>%
      filter(term == "log10(RNA_conc_ng_per_uL)") %>%
      pull(estimate)
    efficiency <- (10^(-1/slope) - 1) * 100
    
    tibble(
      slope = slope,
      efficiency = efficiency,
      label = paste0("Efficiency: ", round(efficiency, 1), "%\nIdeal is 90%-110%"),
      # Position for annotation (use max values from this probe's data)
      x_pos = max(.$RNA_conc_ng_per_uL),
      y_pos = max(.$Ct) - 1
    )
  }) %>%
  ungroup()

# Print efficiency summary
print(efficiency_data %>% select(Probe, slope, efficiency))

# --- Step 3: Create the Faceted ggplot ---
qpcr_plot <- ggplot(
  data = df_raw_filtered,
  aes(x = RNA_conc_ng_per_uL, y = Ct, color = Probe)
) +
  geom_point(alpha = 0.8, size = 3) +
  scale_x_log10(
    breaks = scales::trans_breaks("log10", function(x) 10^x),
    labels = scales::trans_format("log10", scales::math_format(10^.x)),
    name = "RNA Concentration (ng/µL)"
  ) +
  geom_smooth(data = df_raw_filtered %>% filter(RNA_conc_ng_per_uL < 20),
              method = "lm", se = FALSE, formula = y ~ x, color = "black") +
  stat_poly_eq(
    formula = y ~ x,
    aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
    parse = TRUE,
    label.x = "middle",
    label.y = "top",
    color = "black"
  ) +
  # Add efficiency annotation per facet
  geom_text(
    data = efficiency_data,
    aes(x = x_pos, y = y_pos, label = label),
    hjust = 1,
    vjust = 1,
    size = 3.5,
    fontface = "bold",
    color = "black",
    inherit.aes = FALSE
  ) +
  facet_wrap(~ Probe, scales = "free") +
  labs(
    title = "qPCR Standard Curves by Probe",
    subtitle = "Ct Value vs. RNA Concentration",
    y = "Ct Value"
  ) +
  theme_bw() +
  theme(legend.position = "none")

print(qpcr_plot)
```
```{r}
library(dplyr)
library(ggplot2)

# --- Step 1: Filter for the specific concentration ---
df_conc <- raw_data %>%
  filter(
    RT == TRUE,
    !is.na(Ct),
    RNA_conc_ng_per_uL == 5
  )

# --- Step 2: Calculate mean GAPDH Ct as reference ---
gapdh_mean <- df_conc %>%
  filter(Probe == "GAPDH") %>%
  summarise(mean_Ct = mean(Ct, na.rm = TRUE)) %>%
  pull(mean_Ct)

cat("GAPDH mean Ct:", gapdh_mean, "\n")

# --- Step 3: Calculate ΔCt for summary statistics ---
delta_ct_summary <- df_conc %>%
  group_by(Probe) %>%
  summarise(
    mean_Ct = mean(Ct, na.rm = TRUE),
    sd_Ct = sd(Ct, na.rm = TRUE),
    n = n(),
    se_Ct = sd_Ct / sqrt(n),
    .groups = "drop"
  ) %>%
  mutate(
    delta_Ct = mean_Ct - gapdh_mean,
    delta_Ct_se = se_Ct
  )

# --- Step 4: Calculate ΔCt for each raw data point ---
df_conc_delta <- df_conc %>%
  mutate(delta_Ct = Ct - gapdh_mean)

# --- Step 5: Create the plot with raw points ---
delta_ct_plot <- ggplot(
  data = delta_ct_summary,
  aes(x = reorder(Probe, delta_Ct), y = delta_Ct, fill = Probe)
) +
  geom_col(width = 0.7, color = "black", alpha = 0.6) +
  # Add raw data points with jitter to avoid overplotting
  geom_jitter(
    data = df_conc_delta,
    aes(x = Probe, y = delta_Ct),
    width = 0.15,
    size = 2,
    alpha = 0.8,
    color = "black"
  ) +
  geom_errorbar(
    aes(ymin = delta_Ct - delta_Ct_se, ymax = delta_Ct + delta_Ct_se),
    width = 0.2
  ) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray40") +
  labs(
    title = "Relative Ct Values by Probe",
    subtitle = "Normalized to GAPDH at RNA concentration = 5 ng/µL",
    x = "Probe",
    y = expression(Delta*Ct~"(Probe - GAPDH)")
  ) +
  theme_bw() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  scale_y_continuous(breaks = c(-3,0,3,62))

print(delta_ct_plot)
```

