# generated by Claude 3.7 using this prompt + some tweaks:
# author: Jared Bard
# date: 25/03/2024
# Write a python program that cleans up data in a .csv into "tidy" format.
# The program should be designed to run on a command line and use argparse.
# First argument is the input csv.
# Second argument is the output  file_tidy.csv
# Third argument is optional and is the size of the matrix (integer with value of at least 1). Default to 3

# The beginning of the input.csv looks like this:
# "
# User: USER,Path: C:\Program Files (x86)\BMG\CLARIOstar\User\Data,Test run no.: 294
# Test name: FRET_549_646,Date: 3/20/2025,Time: 12:09:50 PM

# Fluorescence (FI), multichromatic

# A01
# X1 Raw Data (Well scan) 550-10/590-10
# 1602,1629,1611
# 1638,1572,1547
# 1603,1603,1600

# A02
# X1 Raw Data (Well scan) 550-10/590-10
# 1870,1736,1622
# 1942,1953,1870
# 1642,1472,1613

# A03
# X2 Raw Data (Well scan) 550-10/590-10
# 1198,1107,1019
# 1088,1098,1049
# 1100,1002,1073
# "

# The program should scan through line by line until encountering a line like "A01" which encodes the "Well" variable
# It should then take the next line as the "Channel" variable
# The next X lines (where X is the size of the matrix) is a table of data. Separate them out with a Matrix_ij variable into a list

# Finally, once the whole file is scanned, format the results using pandas into a dataframe (Filename,Well,Channel,Matrix_ij,Value) and use pandas to export the dataframe as a csv

import argparse
import pandas as pd
import os
import re

def parse_csv(input_file, matrix_size=3):
    """
    Parse the custom CSV format and convert to tidy data.
    
    Args:
        input_file (str): Path to input CSV file
        matrix_size (int): Size of the matrix (default: 3)
        
    Returns:
        pandas.DataFrame: Tidy data frame
    """
    # Extract filename from the input path
    filename = os.path.basename(input_file)
    
    # Data storage
    data = []
    
    # Try different encodings
    encodings = ['utf-8', 'latin-1', 'cp1252']
    lines = None
    
    for encoding in encodings:
        try:
            with open(input_file, 'r', encoding=encoding) as f:
                lines = f.readlines()
            print(f"Successfully read file using {encoding} encoding")
            break  # If successful, exit the loop
        except UnicodeDecodeError:
            continue  # Try the next encoding
    
    if lines is None:
        raise ValueError(f"Could not decode the file {input_file} with any of the attempted encodings.")
    
    line_index = 0
    num_lines = len(lines)
    
    # Skip header until we find a well identifier
    while line_index < num_lines:
        line = lines[line_index].strip()
        
        # Check if this line is a well identifier (like A01, A02, etc.)
        if re.match(r'^[A-Z]+\d+$', line):
            well = line
            line_index += 1
            
            # Next line is the channel information
            if line_index < num_lines:
                channel = lines[line_index].strip()
                line_index += 1
                
                # Next matrix_size lines contain matrix data
                matrix_data = []
                for i in range(matrix_size):
                    if line_index < num_lines:
                        line = lines[line_index].strip()
                        parts = line.split(',')
                        
                        # Check if this looks like matrix data (try to convert to float)
                        try:
                            _ = [float(part.strip()) for part in parts]
                            matrix_data.append(parts)
                            line_index += 1
                        except ValueError:
                            # Not matrix data, we might have hit the next well or the end
                            break
                    else:
                        break
                
                # Process matrix data
                for i in range(len(matrix_data)):
                    for j in range(len(matrix_data[i])):
                        try:
                            value = float(matrix_data[i][j])
                            matrix_position = f"{i+1}-{j+1}"
                            data.append({
                                'Filename': filename,
                                'Well': well,
                                'Channel': channel,
                                'Matrix_ij': matrix_position,
                                'Value': value
                            })
                        except (ValueError, IndexError):
                            # Skip if value can't be converted to float or index out of range
                            pass
        else:
            # Not a well identifier, move to next line
            line_index += 1
    
    # Convert to pandas DataFrame
    return pd.DataFrame(data)

def main():
    """
    Main function to parse arguments and process the CSV file.
    """
    parser = argparse.ArgumentParser(description='Clean up CSV data into tidy format.')
    parser.add_argument('input_csv', help='Path to input CSV file')
    parser.add_argument('--output_csv', help='Path to output CSV file (default: input_basename_tidy.csv)')
    parser.add_argument('--matrix_size', type=int, default=3, 
                        help='Size of the matrix (default: 3)')
    
    args = parser.parse_args()
    
    # Set default output filename if not provided
    if not args.output_csv:
        input_dir = os.path.dirname(args.input_csv)
        input_basename = os.path.splitext(os.path.basename(args.input_csv))[0]
        args.output_csv = os.path.join(input_dir, f"{input_basename}_tidy.csv")
    
    # Validate matrix size
    if args.matrix_size < 1:
        print("Error: Matrix size must be at least 1")
        return
    
    try:
        # Parse the input CSV and convert to tidy format
        df = parse_csv(args.input_csv, args.matrix_size)
    
        # Sort the DataFrame by Filename, Well, Channel, then matrix_ij
        df = df.sort_values(by=['Filename', 'Well', 'Channel', 'Matrix_ij'])
        
        # Save to output CSV
        df.to_csv(args.output_csv, index=False)
        print(f"Tidy data saved to {args.output_csv}")
        print(f"Processed {len(df)} data points")
    except Exception as e:
        print(f"Error processing file: {e}")

if __name__ == "__main__":
    main()